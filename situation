#!/usr/bin/env ruby
# frozen_string_literal: true

# TODO check if git is ahead of remote or behind

require 'optparse'
require 'colorize' # https://github.com/fazibear/colorize

# Class Parser
class Parser
  attr_reader :dummy

  def initialize
    parser = OptionParser.new
    parser.on('-d', '--dummy', 'halp') do
      @dummy = true
    end
    parser.parse!
  end
end

# Class Git
class Git
  attr_reader :name
  attr_reader :path

  def initialize(name, work_tree, git_dir = nil)
    @name = name
    @path = git_dir || work_tree
    git_dir = "#{work_tree}/.git" if git_dir.nil?
    @args = "--git-dir=#{git_dir} --work-tree=#{work_tree}"
  end

  def dirty?
    dirty = `git #{@args} status -s`.chomp
    if dirty.empty?
      false
    else
      true
    end
  end

  def status
    `git #{@args} status -s`.chomp
  end

  def ahead
    `git #{@args} rev-list --count @{u}..`.chomp
  end

  def behind
    `git #{@args} fetch origin`
    `git #{@args} rev-list --count ..@{u}`.chomp
  end
end

[
  Git.new('ansible', File.join(Dir.home, 'ansible')),
  Git.new('scripts', File.join(Dir.home, 'bin')),
  Git.new('dotfiles', Dir.home, File.join(Dir.home, '.dotfiles')),
  Git.new('keys', Dir.home, File.join(Dir.home, '.keys')),
].each do |repo|
  puts "#{'==>'.blue.bold} #{repo.name.bold} #{repo.path.underline}"
  puts "#{' ==>'.yellow.bold} ahead #{repo.ahead.bold} commits" unless repo.ahead.to_i.zero?
  puts "#{' ==>'.red.bold} behind #{repo.behind.bold} commits" unless repo.behind.to_i.zero?
  puts "#{repo.status}" if repo.dirty?
end
